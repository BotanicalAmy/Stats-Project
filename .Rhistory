Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
# Correlation Analysis for Hotel Cancellations
# Convert Status to binary numeric variable (1 = Canceled, 0 = Not_Canceled)
hotel_bookings$Canceled <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
# Create a dataframe with only the variables of interest
analysis_data <- hotel_bookings %>%
select(Canceled, LeadTime, AvgPrice, GroupSize, StayLength)
# Check for missing values
sum(is.na(analysis_data))
# Option 1: Create a correlation matrix
correlation_matrix <- cor(analysis_data, use = "complete.obs")
print(correlation_matrix)
# Option 2: Visualize the correlation matrix
corrplot(correlation_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
diag = FALSE,
title = "Correlation Matrix for Cancellation Prediction",
mar = c(0,0,1,0))
# Option 3: Create point-biserial correlations specifically for binary vs continuous variables
# This is essentially the same as Pearson correlation when one variable is binary
# The correlation with Canceled shows the strength and direction of relationship with cancellation
# Option 4: Statistical testing for variable differences between groups
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
# Option 5: Visualization of variable distributions by cancellation status
# Example for LeadTime
ggplot(hotel_bookings, aes(x = LeadTime, fill = Status)) +
geom_density(alpha = 0.5) +
labs(title = "Distribution of Lead Time by Cancellation Status",
x = "Lead Time (days)",
y = "Density") +
theme_minimal()
# Correlation Analysis for Hotel Cancellations
# Convert Status to binary numeric variable (1 = Canceled, 0 = Not_Canceled)
hotel_bookings$Canceled <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
# new dataframe with only the variables of interest
analysis_data <- hotel_bookings %>%
select(Canceled, LeadTime, AvgPrice, GroupSize, StayLength)
# Option 1: Create a correlation matrix
correlation_matrix <- cor(analysis_data, use = "complete.obs")
print(correlation_matrix)
# correlation matrix for quantitative predictors
corrplot(correlation_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
diag = FALSE,
title = "Correlation Matrix for Cancellation Prediction",
mar = c(0,0,1,0))
# Option 4: Statistical testing for variable differences between groups
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
# Correlation Analysis for Hotel Cancellations
# Convert Status to binary numeric variable (1 = Canceled, 0 = Not_Canceled)
hotel_bookings$Canceled <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
# new dataframe with only the variables of interest
analysis_data <- hotel_bookings %>%
select(Canceled, LeadTime, AvgPrice, GroupSize, StayLength)
# Option 1: Create a correlation matrix
# correlation_matrix <- cor(analysis_data, use = "complete.obs")
# print(correlation_matrix)
# correlation matrix for quantitative predictors
corrplot(correlation_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
diag = FALSE,
title = "Correlation Matrix for Cancellation Prediction",
mar = c(0,0,1,0))
# Option 4: Statistical testing for variable differences between groups
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
# Alternative approach: Create a single plot with facets
# Reshape data from wide to long format for faceting
library(tidyr)
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# Create faceted boxplot
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of Variables by Cancellation Status") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of Quantitative Variables by Cancellation Status") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# front-matter
rm(list = ls()) #clear the workspace
library(Stat2Data)
library(tidyverse)
library(mosaic)
library(ggformula)
library(emmeans)
knitr::opts_chunk$set(echo = F)
# URL to the raw CSV file on GitHub
# this clean version has a series of dates that with odd formatting and missing year and month values as a result
# the dates were reformatted for the affected rows, months and years replaced the missing values
# Use the raw content URL instead of the repository page URL
file_url <- "https://raw.githubusercontent.com/BotanicalAmy/Stats-Project/main/hotel_booking_cleaned.csv"
hotel_bookings <- read.csv(file_url, header = TRUE)
# new column GroupSize by adding Adults and Children
hotel_bookings$GroupSize <- hotel_bookings$Adults + hotel_bookings$Children
# new column StayLength by adding weekend and weeknights
hotel_bookings$StayLength <- hotel_bookings$Weekends + hotel_bookings$Weeknights
# Preview the data
head(hotel_bookings)
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
print(group_comparison)
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# front-matter
rm(list = ls()) #clear the workspace
library(Stat2Data)
library(tidyverse)
library(mosaic)
library(ggformula)
library(emmeans)
library(knitr)
library(kableExtra)
library(dplyr)
knitr::opts_chunk$set(echo = F)
# URL to the raw CSV file on GitHub
# this clean version has a series of dates that with odd formatting and missing year and month values as a result
# the dates were reformatted for the affected rows, months and years replaced the missing values
# Use the raw content URL instead of the repository page URL
file_url <- "https://raw.githubusercontent.com/BotanicalAmy/Stats-Project/main/hotel_booking_clean.csv"
hotel_bookings <- read.csv(file_url, header = TRUE)
# new column GroupSize by adding Adults and Children
hotel_bookings$GroupSize <- hotel_bookings$Adults + hotel_bookings$Children
# new column StayLength by adding weekend and weeknights
hotel_bookings$StayLength <- hotel_bookings$Weekends + hotel_bookings$Weeknights
# Add HasChildren column
hotel_bookings$HasChildren <- ifelse(hotel_bookings$Children > 0, 1, 0)
# Preview the data
# head(hotel_bookings)
# quantitative EDA
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
mutate(across(where(is.numeric), ~round(., 3)))
# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE, background = "#E8E8E8")
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
# categorical EDA
# Create a bar chart with white background and title
gf_bar(~RoomType, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Room Type",
x = "Room Type",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom"
)
)
gf_bar(~Meal, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Meal Type",
x = "Meal Type",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
gf_bar(~Market, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Market Segment",
x = "Market Segment",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
# abbreviated month names in chronological order
month_order <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
# Convert Month to factor with levels in chronological order
hotel_bookings$Month <- factor(hotel_bookings$Month, levels = month_order)
# Create the bar chart with chronologically ordered months
gf_bar(~Month, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellations by Month",
x = "Month",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
gf_bar(~Requests, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellations by Request Count",
x = "Number of Special Requests",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
gf_bar(~HasChildren, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by HasChildren",
x = "Has Children (0 = No, 1 = Yes)",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
gf_bar(~Parking, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Parking Option",
x = "Parking",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom"
)
)
# Create a function to generate proportion tables
create_prop_table <- function(data, group_var) {
group_var <- enquo(group_var)
data %>%
group_by(!!group_var, Status) %>%
summarise(count = n(), .groups = "drop") %>%
group_by(!!group_var) %>%
mutate(proportion = count / sum(count))
}
# Now use the function with each variable
room_type_table <- create_prop_table(hotel_bookings, RoomType)
meal_table <- create_prop_table(hotel_bookings, Meal)
market_table <- create_prop_table(hotel_bookings, Market)
parking_table <- create_prop_table(hotel_bookings, Parking)
month_table <- create_prop_table(hotel_bookings, Month)
requests_table <- create_prop_table(hotel_bookings, Requests)
children_table <- create_prop_table(hotel_bookings, HasChildren)
# Function to create a nicely formatted kable table with rounded proportions
print_pretty_kable <- function(table_data, title) {
table_data <- table_data %>%
mutate(proportion = round(proportion, 3))
kable(table_data, caption = title) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE, background = "#E8E8E8")
}
# Print each table with nice formatting
print_pretty_kable(room_type_table, "Room Type")
print_pretty_kable(meal_table, "Meal Option")
print_pretty_kable(market_table, "Market")
print_pretty_kable(parking_table, "Parking")
print_pretty_kable(month_table, "Month")
print_pretty_kable(requests_table, "Special Requests")
print_pretty_kable(children_table, "Has Children")
# quantitative predictors
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
summary(price_model)
leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
summary(leadtime_model)
staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
request_model <- glm(factor(Status) ~ Requests, family = binomial(link = "logit"), data = hotel_bookings)
summary(request_model)
#ASSESS
#converts status to binary where Canceled = 1 and Not_Canceled = 0, checking for linearity
hotel_bookings$Status_binary <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
emplogitplot1(Status_binary ~ LeadTime, data = hotel_bookings, ngroups = "all")
plot(leadtime_model, which = 1)
#USE
summary(leadtime_model)
mod1 <- glm(factor(Status) ~ RoomType, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod1)
plot(mod1, which = 1)
mod2 <- glm(factor(Status) ~ Parking, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod2)
plot(mod2, which = 1)
mod3 <- glm(factor(Status) ~ Market, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod3)
plot(mod3, which = 1)
mod4 <- glm(factor(Status) ~ Meal, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod4)
plot(mod4, which = 1)
mod5 <- glm(factor(Status) ~ Month, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)
confint.default(mod5)
plot(mod5, which = 1)
#gets the confidence interval, which does not include 0 therefore valid
confint.default(leadtime_model)
#gets the CI on the odds ratio scale, for every 1 unit increase in LeadTime, the odds of cancellation
#(vs. non-cancellation) multiply by 0.9880 to 0.9881 w/95% confidence
exp(confint.default(leadtime_model))
# add table
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
summary(price_model)
leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
summary(leadtime_model)
staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
# quantitative EDA
#ASSESS
#converts status to binary where Canceled = 1 and Not_Canceled = 0, checking for linearity
hotel_bookings$Status_binary <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
emplogitplot1(Status_binary ~ LeadTime, data = hotel_bookings, ngroups = "all")
plot(leadtime_model, which = 1)
#USE
summary(leadtime_model)
#gets the confidence interval, which does not include 0 therefore valid
confint.default(leadtime_model)
#gets the CI on the odds ratio scale, for every 1 unit increase in LeadTime, the odds of cancellation
#(vs. non-cancellation) multiply by 0.9880 to 0.9881 w/95% confidence
exp(confint.default(leadtime_model))
# categorical EDA
gf_bar(~HasChildren, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by HasChildren",
x = "Has Children (0 = No, 1 = Yes)",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
gf_bar(~Parking, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Parking Option",
x = "Parking",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
