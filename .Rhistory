)
# Calculate average predicted probability and observed proportion for each bin
bin_summary <- aggregate(cbind(pred, actual) ~ bin, data = bin_data,
FUN = function(x) c(mean(x)))
# Calculate empirical logit
bin_summary$logit_pred <- log(bin_summary$pred / (1 - bin_summary$pred))
bin_summary$logit_actual <- log((bin_summary$actual + 0.5/nrow(bin_summary)) /
(1 - bin_summary$actual + 0.5/nrow(bin_summary)))
# Count observations per bin
bin_counts <- table(bin_groups)
bin_summary$count <- as.vector(bin_counts)
# Create plot
plot(bin_summary$logit_pred, bin_summary$logit_actual,
xlab = "Predicted logit", ylab = "Observed logit",
main = "Empirical Logit Plot for Model Fit",
pch = 19, cex = sqrt(bin_summary$count / max(bin_summary$count)) * 2)
# Add reference line (y = x)
abline(0, 1, col = "red", lty = 2)
# Add regression line
abline(lm(logit_actual ~ logit_pred, data = bin_summary,
weights = count), col = "blue")
# Add legend
legend("topleft", legend = c("Perfect fit", "Actual fit"),
col = c("red", "blue"), lty = c(2, 1))
return(bin_summary)
}
# Create the empirical logit plot for the model
model_fit <- plot_model_fit(new_model, bins = 10)
# Print the bin summary data
#print(model_fit)
# Other diagnostic plots for the model
plot(new_model, which = c(1, 2))  # Residuals vs Fitted and Normal Q-Q plot
#cross validation
set.seed(123)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.5 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
train_model <- glm(factor(Status) ~ LeadTime + HasRequests + factor(Market) + factor(Month) +
AvgPrice + factor(Parking) + factor(RoomType) + StayLength + factor(Meal) + StayLength,
family = binomial(link = "logit"),
data = train_data)
summary(train_model)
anova(train_model)
train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")
train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1
logL <- sum(test_actual * log(test_predictions) + (1 - test_actual) * log(1 - test_predictions))
k <- length(coef(train_model))
aic_test <- 2 * k - 2 * logL
(aic_test - AIC(train_model))/AIC(train_model)
#cross validation
set.seed(456)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.5 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
train_model <- glm(factor(Status) ~ LeadTime + HasRequests + factor(Market) + factor(Month) +
AvgPrice + factor(Parking) + factor(RoomType) + StayLength + factor(Meal) + StayLength,
family = binomial(link = "logit"),
data = train_data)
summary(train_model)
anova(train_model)
train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")
train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1
logL <- sum(test_actual * log(test_predictions) + (1 - test_actual) * log(1 - test_predictions))
k <- length(coef(train_model))
aic_test <- 2 * k - 2 * logL
(aic_test - AIC(train_model))/AIC(train_model)
# included again in the appendix, left here for ease of reference or modification
new_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests + factor(Month) + AvgPrice + StayLength, family = binomial(link = "logit"), data=hotel_bookings)
anova_table <- Anova(new_model, test = "LR")
# print(anova_table)
# Get the AIC
# AIC(new_model)
#ASSESS
# Create an empirical logit plot for the entire model
plot_model_fit <- function(model, bins = 10) {
# Get predicted probabilities from the model
pred_probs <- predict(model, type = "response")
# Get actual responses (as 0/1)
actual <- as.numeric(model$model[[1]]) - 1
# Create bins based on predicted probabilities
breaks <- quantile(pred_probs, probs = seq(0, 1, length.out = bins + 1))
bin_groups <- cut(pred_probs, breaks = breaks, include.lowest = TRUE)
# Calculate empirical logit for each bin
bin_data <- data.frame(
bin = bin_groups,
pred = pred_probs,
actual = actual
)
# Calculate average predicted probability and observed proportion for each bin
bin_summary <- aggregate(cbind(pred, actual) ~ bin, data = bin_data,
FUN = function(x) c(mean(x)))
# Calculate empirical logit
bin_summary$logit_pred <- log(bin_summary$pred / (1 - bin_summary$pred))
bin_summary$logit_actual <- log((bin_summary$actual + 0.5/nrow(bin_summary)) /
(1 - bin_summary$actual + 0.5/nrow(bin_summary)))
# Count observations per bin
bin_counts <- table(bin_groups)
bin_summary$count <- as.vector(bin_counts)
# Create plot
plot(bin_summary$logit_pred, bin_summary$logit_actual,
xlab = "Predicted logit", ylab = "Observed logit",
main = "Empirical Logit Plot for Model Fit",
pch = 19, cex = sqrt(bin_summary$count / max(bin_summary$count)) * 2)
# Add reference line (y = x)
abline(0, 1, col = "red", lty = 2)
# Add regression line
abline(lm(logit_actual ~ logit_pred, data = bin_summary,
weights = count), col = "blue")
# Add legend
legend("topleft", legend = c("Perfect fit", "Actual fit"),
col = c("red", "blue"), lty = c(2, 1))
return(bin_summary)
}
# Create the empirical logit plot for the model
model_fit <- plot_model_fit(new_model, bins = 10)
# Print the bin summary data
#print(model_fit)
# Other diagnostic plots for the model
plot(new_model, which = c(1, 2))  # Residuals vs Fitted and Normal Q-Q plot
#cross validation, note- this validation not included in the description (text still notes my original k fold analysis)
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
# get predictions for both training and test data
train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")
# Convert actual values to binary for comparison
train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1
# Calculate correlation in training data
# train_correlation <- cor(train_predictions, train_actual)
# print(paste("Training correlation:", round(train_correlation, 4)))
# Calculate correlation in test data (this is the CVC)
# test_correlation <- cor(test_predictions, test_actual)
# print(paste("Cross-validation correlation (CVC):", round(test_correlation, 4)))
# Calculate shrinkage
# shrinkage <- train_correlation - test_correlation
# print(paste("Shrinkage:", round(shrinkage, 4)))
# print(paste("Shrinkage percentage:", round(shrinkage/train_correlation * 100, 2), "%"))
# side-by-side bar chart of canceled bookings by market type for 2017-2018
# Filter for canceled bookings in 2017 and 2018 only
canceled_bookings <- hotel_bookings[hotel_bookings$Status == "Canceled" &
(hotel_bookings$Year == 2017 |
hotel_bookings$Year == 2018), ]
# Create a binary market type variable (Online vs Non-Online)
canceled_bookings$MarketType <- ifelse(canceled_bookings$Market == "Online",
"Online", "Non-Online")
# Create a contingency table of counts
cancellation_counts <- table(canceled_bookings$Year, canceled_bookings$MarketType)
# Convert to data frame for ggplot
cancellation_df <- as.data.frame(cancellation_counts)
colnames(cancellation_df) <- c("Year", "MarketType", "Count")
# Convert Year to factor for proper ordering
cancellation_df$Year <- as.factor(cancellation_df$Year)
# Create the side-by-side (unstacked) bar chart
ggplot(cancellation_df, aes(x = Year, y = Count, fill = MarketType)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
scale_fill_manual(values = c("Online" = "darkblue", "Non-Online" = "azure4")) +
labs(title = "Canceled Bookings by Market Type (2017-2018)",
subtitle = "Side-by-side comparison of Online vs Non-Online Markets",
x = "Year",
y = "Number of Cancellations",
fill = "Market Type") +
theme_minimal() +
theme(
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10),
legend.position = "bottom",
legend.title = element_text(size = 11),
legend.text = element_text(size = 10),
panel.grid = element_blank()  # Keep the gridlines removed
) +
# Add data labels on top of each bar
geom_text(aes(label = Count), position = position_dodge(width = 0.7),
vjust = -0.5, size = 3.5) +
# Set y-axis to start at 0
scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
# side-by-side bar chart of canceled bookings by market type for 2017-2018
# Filter for canceled bookings in 2017 and 2018 only
canceled_bookings <- hotel_bookings[hotel_bookings$Status == "Canceled" &
(hotel_bookings$Year == 2017 |
hotel_bookings$Year == 2018), ]
# Create a binary market type variable (Online vs Non-Online)
canceled_bookings$MarketType <- ifelse(canceled_bookings$Market == "Online",
"Online", "Non-Online")
# Create a contingency table of counts
cancellation_counts <- table(canceled_bookings$Year, canceled_bookings$MarketType)
# Convert to data frame for ggplot
cancellation_df <- as.data.frame(cancellation_counts)
colnames(cancellation_df) <- c("Year", "MarketType", "Count")
# Convert Year to factor for proper ordering
cancellation_df$Year <- as.factor(cancellation_df$Year)
# Create the side-by-side (unstacked) bar chart
ggplot(cancellation_df, aes(x = Year, y = Count, fill = MarketType)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
scale_fill_manual(values = c("Online" = "darkblue", "Non-Online" = "azure4")) +
labs(title = "Canceled Bookings by Market Type (2017-2018)",
subtitle = "Side-by-side comparison of Online vs Non-Online Markets",
x = "Year",
y = "Number of Cancellations",
fill = "Market Type") +
theme_minimal() +
theme(
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10),
legend.position = "bottom",
legend.title = element_text(size = 11),
legend.text = element_text(size = 10),
panel.grid = element_blank()  # Keep the gridlines removed
) +
# Add data labels on top of each bar
geom_text(aes(label = Count), position = position_dodge(width = 0.7),
vjust = -0.5, size = 3.5) +
# Set y-axis to start at 0
scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
# function to generate proportion tables
create_prop_table <- function(data, group_var) {
group_var <- enquo(group_var)
data %>%
group_by(!!group_var, Status) %>%
summarise(count = n(), .groups = "drop") %>%
group_by(!!group_var) %>%
mutate(proportion = count / sum(count))
}
# using the function with each variable
room_type_table <- create_prop_table(hotel_bookings, RoomType)
meal_table <- create_prop_table(hotel_bookings, Meal)
market_table <- create_prop_table(hotel_bookings, Market)
parking_table <- create_prop_table(hotel_bookings, Parking)
month_table <- create_prop_table(hotel_bookings, Month)
requests_table <- create_prop_table(hotel_bookings, HasRequests)
children_table <- create_prop_table(hotel_bookings, HasChildren)
online_table <- create_prop_table(hotel_bookings, Online)
requests_table2 <- create_prop_table(hotel_bookings, Requests)
# using the function to create a nicely formatted kable table with rounded proportions
print_pretty_kable <- function(table_data, title) {
table_data <- table_data %>%
mutate(proportion = round(proportion, 3))
kable(table_data, caption = title) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE)
}
#printed tables are separated with lines of code to prevent awkward cut offs
# Print each table with nice formatting
print_pretty_kable(room_type_table, "Room Type")
print_pretty_kable(meal_table, "Meal Option")
# Print each table with nice formatting
print_pretty_kable(market_table, "Market")
print_pretty_kable(parking_table, "Parking")
# Print each table with nice formatting
print_pretty_kable(month_table, "Month")
print_pretty_kable(requests_table, "Has Requests")
# Print each table with nice formatting
print_pretty_kable(children_table, "Has Children")
print_pretty_kable(online_table, "Online Booking")
print_pretty_kable(requests_table2, "Requests")
# quantitative code
hotel_bookings$Status_binary <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
summary(price_model)
emplogitplot1(Status_binary ~ AvgPrice, data = hotel_bookings, ngroups = "all")
leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
summary(leadtime_model)
emplogitplot1(Status_binary ~ LeadTime, data = hotel_bookings, ngroups = "all")
staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
emplogitplot1(Status_binary ~ StayLength, data = hotel_bookings, ngroups = "all")
groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ GroupSize, data = hotel_bookings, ngroups = "all")
groupsize_model <- glm(factor(Status) ~ Adults, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Adults, data = hotel_bookings, ngroups = "all")
groupsize_model <- glm(factor(Status) ~ Children, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Children, data = hotel_bookings, ngroups = "all")
groupsize_model <- glm(factor(Status) ~ Weekends, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Weekends, data = hotel_bookings, ngroups = "all")
groupsize_model <- glm(factor(Status) ~ Weeknights, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Weeknights, data = hotel_bookings, ngroups = "all")
staylength_model <- glm(factor(Status) ~ Requests, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
emplogitplot1(Status_binary ~ Requests, data = hotel_bookings, ngroups = "all")
# categorical code
mod1 <- glm(factor(Status) ~ RoomType, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod1)
mod2 <- glm(factor(Status) ~ Parking, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod2)
mod3 <- glm(factor(Status) ~ Market, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod3)
mod4 <- glm(factor(Status) ~ Meal, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod4)
mod5 <- glm(factor(Status) ~ Month, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)
mod5 <- glm(factor(Status) ~ HasRequests, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)
mod5 <- glm(factor(Status) ~ HasChildren, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)
#full model code
full_model <- glm(factor(Status) ~ factor(Meal) + factor(Parking) + factor(RoomType) + LeadTime + factor(Market) + AvgPrice + HasRequests + factor(Month) + StayLength + GroupSize, family = binomial(link = "logit"), data=hotel_bookings)
none <- glm(factor(Status) ~ 1 , family = binomial(link = "logit"), data=hotel_bookings)
step(none,scope=list(upper= full_model), direction = "forward")
anova_table <- Anova(full_model, test = "LR")
print(anova_table)
#final model code
new_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests + factor(Month) + AvgPrice + StayLength, family = binomial(link = "logit"), data=hotel_bookings)
anova_table <- Anova(new_model, test = "LR")
print(anova_table)
# Get the AIC
AIC(new_model)
#cross validation
set.seed(123)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.5 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
train_model <- glm(factor(Status) ~ LeadTime + HasRequests + factor(Market) + factor(Month) +
AvgPrice + factor(Parking) + factor(RoomType) + StayLength + factor(Meal) + StayLength,
family = binomial(link = "logit"),
data = train_data)
summary(train_model)
anova(train_model)
train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")
train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1
logL <- sum(test_actual * log(test_predictions) + (1 - test_actual) * log(1 - test_predictions))
k <- length(coef(train_model))
aic_test <- 2 * k - 2 * logL
(aic_test - AIC(train_model))/AIC(train_model)
#cross validation
set.seed(456)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.5 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
train_model <- glm(factor(Status) ~ LeadTime + HasRequests + factor(Market) + factor(Month) +
AvgPrice + factor(Parking) + factor(RoomType) + StayLength + factor(Meal) + StayLength,
family = binomial(link = "logit"),
data = train_data)
summary(train_model)
anova(train_model)
train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")
train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1
logL <- sum(test_actual * log(test_predictions) + (1 - test_actual) * log(1 - test_predictions))
k <- length(coef(train_model))
aic_test <- 2 * k - 2 * logL
(aic_test - AIC(train_model))/AIC(train_model)
# quantitative EDA
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
mutate(across(where(is.numeric), ~round(., 3)))
# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE)
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(Adults, na.rm = TRUE),
Mean_AvgPrice = mean(Children, na.rm = TRUE),
Mean_GroupSize = mean(Weekends, na.rm = TRUE),
Mean_StayLength = mean(Weeknights, na.rm = TRUE)
)
# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
mutate(across(where(is.numeric), ~round(., 3)))
# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables Table 2") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE)
hotel_long <- hotel_bookings %>%
select(Status, Adults, Children, Weekends, Weeknights) %>%
pivot_longer(cols = c(Adults, Children, Weekends, Weeknights),
names_to = "Variable",
values_to = "Value")
#second section
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
hotel_long <- hotel_bookings %>%
select(Status, Requests) %>%
pivot_longer(cols = c(Requests),
names_to = "Variable",
values_to = "Value")
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
# quantitative EDA
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
mutate(across(where(is.numeric), ~round(., 3)))
# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE)
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(Adults, na.rm = TRUE),
Mean_AvgPrice = mean(Children, na.rm = TRUE),
Mean_GroupSize = mean(Weekends, na.rm = TRUE),
Mean_StayLength = mean(Weeknights, na.rm = TRUE)
)
# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
mutate(across(where(is.numeric), ~round(., 3)))
#second section
# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables Table 2") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE)
hotel_long <- hotel_bookings %>%
select(Status, Adults, Children, Weekends, Weeknights) %>%
pivot_longer(cols = c(Adults, Children, Weekends, Weeknights),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
hotel_long <- hotel_bookings %>%
select(Status, Requests) %>%
pivot_longer(cols = c(Requests),
names_to = "Variable",
values_to = "Value")
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
