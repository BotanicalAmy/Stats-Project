"Online", "Non-Online")
# Create a contingency table of counts
cancellation_counts <- table(canceled_bookings$Year, canceled_bookings$MarketType)
# Convert to data frame for ggplot
cancellation_df <- as.data.frame(cancellation_counts)
colnames(cancellation_df) <- c("Year", "MarketType", "Count")
# Convert Year to factor for proper ordering
cancellation_df$Year <- as.factor(cancellation_df$Year)
# Create the side-by-side (unstacked) bar chart
ggplot(cancellation_df, aes(x = Year, y = Count, fill = MarketType)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
scale_fill_manual(values = c("Online" = "darkblue", "Non-Online" = "azure4")) +
labs(title = "Canceled Bookings by Market Type (2017-2018)",
subtitle = "Side-by-side comparison of Online vs Non-Online Markets",
x = "Year",
y = "Number of Cancellations",
fill = "Market Type") +
theme_minimal() +
theme(
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10),
legend.position = "bottom",
legend.title = element_text(size = 11),
legend.text = element_text(size = 10),
panel.grid = element_blank()  # Keep the gridlines removed
) +
# Add data labels on top of each bar
geom_text(aes(label = Count), position = position_dodge(width = 0.7),
vjust = -0.5, size = 3.5) +
# Set y-axis to start at 0
scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
# quantitative code
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
summary(price_model)
leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
summary(leadtime_model)
staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
# categorical code
modr <- glm(factor(Status) ~ Requests, family = binomial(link = "logit"), data = hotel_bookings)
summary(modr)
mod1 <- glm(factor(Status) ~ RoomType, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod1)
mod2 <- glm(factor(Status) ~ Parking, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod2)
mod3 <- glm(factor(Status) ~ Market, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod3)
mod4 <- glm(factor(Status) ~ Meal, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod4)
mod5 <- glm(factor(Status) ~ Month, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)
#full model code
full_model <- glm(factor(Status) ~ factor(Meal) + factor(Parking) + factor(RoomType) + LeadTime + factor(Market) + AvgPrice + HasRequests + factor(Month) + StayLength + GroupSize, family = binomial(link = "logit"), data=hotel_bookings)
none <- glm(factor(Status) ~ 1 , family = binomial(link = "logit"), data=hotel_bookings)
step(none,scope=list(upper= full_model), direction = "forward")
anova_table <- Anova(full_model, test = "LR")
print(anova_table)
#final model code
new_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests + factor(Month) + AvgPrice + StayLength, family = binomial(link = "logit"), data=hotel_bookings)
anova_table <- Anova(new_model, test = "LR")
print(anova_table)
# Get the AIC
AIC(new_model)
# function to generate proportion tables
create_prop_table <- function(data, group_var) {
group_var <- enquo(group_var)
data %>%
group_by(!!group_var, Status) %>%
summarise(count = n(), .groups = "drop") %>%
group_by(!!group_var) %>%
mutate(proportion = count / sum(count))
}
# Now use the function with each variable
room_type_table <- create_prop_table(hotel_bookings, RoomType)
meal_table <- create_prop_table(hotel_bookings, Meal)
market_table <- create_prop_table(hotel_bookings, Market)
parking_table <- create_prop_table(hotel_bookings, Parking)
month_table <- create_prop_table(hotel_bookings, Month)
requests_table <- create_prop_table(hotel_bookings, HasRequests)
children_table <- create_prop_table(hotel_bookings, HasChildren)
online_table <- create_prop_table(hotel_bookings, Online)
# Function to create a nicely formatted kable table with rounded proportions
print_pretty_kable <- function(table_data, title) {
table_data <- table_data %>%
mutate(proportion = round(proportion, 3))
kable(table_data, caption = title) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE)
}
# Print each table with nice formatting
print_pretty_kable(room_type_table, "Room Type")
print_pretty_kable(meal_table, "Meal Option")
print_pretty_kable(market_table, "Market")
print_pretty_kable(parking_table, "Parking")
print_pretty_kable(month_table, "Month")
print_pretty_kable(requests_table, "Special Requests")
print_pretty_kable(children_table, "Has Children")
print_pretty_kable(online_table, "Online Booking")
# front-matter
rm(list = ls()) #clear the workspace
library(Stat2Data)
library(tidyverse)
library(mosaic)
library(ggformula)
library(emmeans)
library(knitr)
library(kableExtra)
library(dplyr)
library(car)
library(ggplot2)
knitr::opts_chunk$set(echo = F)
# URL to the raw CSV file on GitHub
# this clean version has a series of dates that with odd formatting and missing year and month values as a result
# the dates were reformatted for the affected rows, months and years replaced the missing values
# Use the raw content URL instead of the repository page URL
file_url <- "https://raw.githubusercontent.com/BotanicalAmy/Stats-Project/main/hotel_booking_clean.csv"
hotel_bookings <- read.csv(file_url, header = TRUE)
# new column GroupSize by adding Adults and Children
hotel_bookings$GroupSize <- hotel_bookings$Adults + hotel_bookings$Children
# new column StayLength by adding weekend and weeknights
hotel_bookings$StayLength <- hotel_bookings$Weekends + hotel_bookings$Weeknights
# Add HasChildren column
hotel_bookings$HasChildren <- ifelse(hotel_bookings$Children > 0, 1, 0)
# Add HasRequest column
hotel_bookings$HasRequests <- ifelse(hotel_bookings$Requests > 0, 1, 0)
# Add Online column
hotel_bookings$Online <- ifelse(hotel_bookings$Market == "Online", 1, 0)
# Preview the data
# head(hotel_bookings)
#gets the confidence interval, which does not include 0 therefore valid
# confint.default(leadtime_model)
#gets the CI on the odds ratio scale, for every 1 unit increase in LeadTime, the odds of cancellation
#(vs. non-cancellation) multiply by 0.9880 to 0.9881 w/95% confidence
# exp(confint.default(leadtime_model))
#confidence interval for HasRequests
# confint.default(modr)
# side-by-side bar chart of canceled bookings by market type for 2017-2018
# Filter for canceled bookings in 2017 and 2018 only
canceled_bookings <- hotel_bookings[hotel_bookings$Status == "Canceled" &
(hotel_bookings$Year == 2017 |
hotel_bookings$Year == 2018), ]
# Create a binary market type variable (Online vs Non-Online)
canceled_bookings$MarketType <- ifelse(canceled_bookings$Market == "Online",
"Online", "Non-Online")
# Create a contingency table of counts
cancellation_counts <- table(canceled_bookings$Year, canceled_bookings$MarketType)
# Convert to data frame for ggplot
cancellation_df <- as.data.frame(cancellation_counts)
colnames(cancellation_df) <- c("Year", "MarketType", "Count")
# Convert Year to factor for proper ordering
cancellation_df$Year <- as.factor(cancellation_df$Year)
# Create the side-by-side (unstacked) bar chart
ggplot(cancellation_df, aes(x = Year, y = Count, fill = MarketType)) +
geom_bar(stat = "identity", position = "dodge", width = 0.7) +
scale_fill_manual(values = c("Online" = "darkblue", "Non-Online" = "azure4")) +
labs(title = "Canceled Bookings by Market Type (2017-2018)",
subtitle = "Side-by-side comparison of Online vs Non-Online Markets",
x = "Year",
y = "Number of Cancellations",
fill = "Market Type") +
theme_minimal() +
theme(
plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10),
legend.position = "bottom",
legend.title = element_text(size = 11),
legend.text = element_text(size = 10),
panel.grid = element_blank()  # Keep the gridlines removed
) +
# Add data labels on top of each bar
geom_text(aes(label = Count), position = position_dodge(width = 0.7),
vjust = -0.5, size = 3.5) +
# Set y-axis to start at 0
scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
# quantitative code
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
summary(price_model)
leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
summary(leadtime_model)
staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
# categorical code
modr <- glm(factor(Status) ~ Requests, family = binomial(link = "logit"), data = hotel_bookings)
summary(modr)
mod1 <- glm(factor(Status) ~ RoomType, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod1)
mod2 <- glm(factor(Status) ~ Parking, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod2)
mod3 <- glm(factor(Status) ~ Market, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod3)
mod4 <- glm(factor(Status) ~ Meal, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod4)
mod5 <- glm(factor(Status) ~ Month, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)
#full model code
full_model <- glm(factor(Status) ~ factor(Meal) + factor(Parking) + factor(RoomType) + LeadTime + factor(Market) + AvgPrice + HasRequests + factor(Month) + StayLength + GroupSize, family = binomial(link = "logit"), data=hotel_bookings)
none <- glm(factor(Status) ~ 1 , family = binomial(link = "logit"), data=hotel_bookings)
step(none,scope=list(upper= full_model), direction = "forward")
anova_table <- Anova(full_model, test = "LR")
print(anova_table)
#final model code
new_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests + factor(Month) + AvgPrice + StayLength, family = binomial(link = "logit"), data=hotel_bookings)
anova_table <- Anova(new_model, test = "LR")
print(anova_table)
# Get the AIC
AIC(new_model)
#Cross validation
# Set seed for reproducibility
set.seed(123)
# Define number of folds
k <- 10
# Create folds
folds <- sample(1:k, nrow(hotel_bookings), replace = TRUE)
# Initialize performance metrics
cv_metrics <- data.frame(
fold = 1:k,
accuracy = numeric(k),
sensitivity = numeric(k),
specificity = numeric(k),
auc = numeric(k)
)
# Perform k-fold cross-validation
for (i in 1:k) {
# Split data into training and test sets
train_data <- hotel_bookings[folds != i, ]
test_data <- hotel_bookings[folds == i, ]
# Fit model on training data
cv_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
# Make predictions on test data
predictions <- predict(cv_model, newdata = test_data, type = "response")
predicted_class <- ifelse(predictions > 0.5, 1, 0)
actual_class <- as.numeric(factor(test_data$Status)) - 1
# Create confusion matrix
conf_matrix <- table(Predicted = predicted_class, Actual = actual_class)
# Calculate performance metrics
if (dim(conf_matrix)[1] == 2 && dim(conf_matrix)[2] == 2) {
# When both classes are present in the fold
accuracy <- sum(diag(conf_matrix)) / sum(conf_matrix)
sensitivity <- conf_matrix[2, 2] / sum(conf_matrix[, 2])
specificity <- conf_matrix[1, 1] / sum(conf_matrix[, 1])
# Calculate AUC
library(pROC)
roc_obj <- roc(actual_class, predictions)
auc_value <- auc(roc_obj)
} else {
# Handle edge case when a fold might be missing a class
accuracy <- sum(predicted_class == actual_class) / length(actual_class)
sensitivity <- NA
specificity <- NA
auc_value <- NA
}
# Store metrics for this fold
cv_metrics$accuracy[i] <- accuracy
cv_metrics$sensitivity[i] <- sensitivity
cv_metrics$specificity[i] <- specificity
cv_metrics$auc[i] <- auc_value
}
# Calculate average performance across folds
cv_summary <- colMeans(cv_metrics[, -1], na.rm = TRUE)
cv_sd <- apply(cv_metrics[, -1], 2, sd, na.rm = TRUE)
# Print results
print("Cross-validation results:")
print(cv_metrics)
print("Average performance:")
print(cv_summary)
print("Standard deviation of performance:")
#data summary of folds
print(cv_sd)
# front-matter
rm(list = ls()) #clear the workspace
library(Stat2Data)
library(tidyverse)
library(mosaic)
library(ggformula)
library(emmeans)
library(knitr)
library(kableExtra)
library(dplyr)
library(car)
library(ggplot2)
knitr::opts_chunk$set(echo = F)
# URL to the raw CSV file on GitHub
# this clean version has a series of dates that with odd formatting and missing year and month values as a result
# the dates were reformatted for the affected rows, months and years replaced the missing values
# Use the raw content URL instead of the repository page URL
file_url <- "https://raw.githubusercontent.com/BotanicalAmy/Stats-Project/main/hotel_booking_clean.csv"
hotel_bookings <- read.csv(file_url, header = TRUE)
# new column GroupSize by adding Adults and Children
hotel_bookings$GroupSize <- hotel_bookings$Adults + hotel_bookings$Children
# new column StayLength by adding weekend and weeknights
hotel_bookings$StayLength <- hotel_bookings$Weekends + hotel_bookings$Weeknights
# Add HasChildren column
hotel_bookings$HasChildren <- ifelse(hotel_bookings$Children > 0, 1, 0)
# Add HasRequest column
hotel_bookings$HasRequests <- ifelse(hotel_bookings$Requests > 0, 1, 0)
# Add Online column
hotel_bookings$Online <- ifelse(hotel_bookings$Market == "Online", 1, 0)
# Preview the data
# head(hotel_bookings)
# quantitative EDA
# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
group_by(Status) %>%
summarize(
Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
Mean_StayLength = mean(StayLength, na.rm = TRUE)
)
# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
mutate(across(where(is.numeric), ~round(., 3)))
# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE) %>%
column_spec(1, bold = TRUE) %>%
row_spec(0, bold = TRUE, background = "#E8E8E8")
hotel_long <- hotel_bookings %>%
select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
names_to = "Variable",
values_to = "Value")
# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
geom_boxplot() +
facet_wrap(~ Variable, scales = "free_y") +
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
labs(title = "Comparison of quantitative variables by cancellation status") +
theme_minimal()
# categorical EDA
# Create a bar chart with white background and title
gf_bar(~RoomType, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Room Type",
x = "Room Type",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom"
)
)
gf_bar(~Meal, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Meal Type",
x = "Meal Type",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
gf_bar(~Market, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellation by Market Segment",
x = "Market Segment",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
# abbreviated month names in chronological order
month_order <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
# Convert Month to factor with levels in chronological order
hotel_bookings$Month <- factor(hotel_bookings$Month, levels = month_order)
# Create the bar chart with chronologically ordered months
gf_bar(~Month, fill=~Status, data = hotel_bookings) %>%
gf_labs(
title = "Cancellations by Month",
x = "Month",
y = "Count"
) %>%
gf_refine(
scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
) %>%
gf_theme(
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
legend.position = "bottom"
)
)
#cross validation
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
summary(train_model)
#cross validation
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
anova(train_model)
#cross validation
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
summary(train_model)
#cross validation
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
# test the model
testing_predictions <- predict.lm(GPA_model, newdata=test_data)
#cross validation
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
# test the model
testing_predictions <- predict.lm(train_model, newdata=test_data)
cbind(testing_predictions, test_data$Status)
#cross validation
# Set seed for reproducibility
set.seed(123)
# Create a random split (80% training, 20% test)
train_indices <- sample(1:nrow(hotel_bookings), size = 0.8 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]
# Build the model on training data
train_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests +
factor(Month) + AvgPrice + StayLength,
family = binomial(link = "logit"),
data = train_data)
# get predictions for both training and test data
train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")
# Convert actual values to binary for comparison
train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1
# Calculate correlation in training data
train_correlation <- cor(train_predictions, train_actual)
print(paste("Training correlation:", round(train_correlation, 4)))
# Calculate correlation in test data (this is the CVC)
test_correlation <- cor(test_predictions, test_actual)
print(paste("Cross-validation correlation (CVC):", round(test_correlation, 4)))
# Calculate shrinkage
shrinkage <- train_correlation - test_correlation
print(paste("Shrinkage:", round(shrinkage, 4)))
print(paste("Shrinkage percentage:", round(shrinkage/train_correlation * 100, 2), "%"))
