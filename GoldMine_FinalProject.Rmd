---
title: 'MATH 324 Final Project'
author: "Amy Cao, Amy Folkestad, Anker Hojgaard and Jaxson Stathis"
output:
  pdf_document: default
  html_notebook: default
---

  
```{r, include = F, warning=F, message=F}
# front-matter
rm(list = ls()) #clear the workspace

library(Stat2Data)
library(tidyverse)
library(mosaic)
library(ggformula)
library(emmeans)
library(knitr)
library(kableExtra)
library(dplyr)
library(car)
library(ggplot2)

# install the missing package- this is what was preventing the knit (Amy F already had this installed)
#tinytex::tlmgr_install("multirow")

knitr::opts_chunk$set(echo = F)

# URL to the raw CSV file on GitHub
# this clean version has a series of dates that with odd formatting and missing year and month values as a result
# the dates were reformatted for the affected rows, months and years replaced the missing values

# Use the raw content URL instead of the repository page URL
file_url <- "https://raw.githubusercontent.com/BotanicalAmy/Stats-Project/main/hotel_booking_clean.csv"
hotel_bookings <- read.csv(file_url, header = TRUE)

```

```{r}
# new column GroupSize by adding Adults and Children
hotel_bookings$GroupSize <- hotel_bookings$Adults + hotel_bookings$Children

# new column StayLength by adding weekend and weeknights
hotel_bookings$StayLength <- hotel_bookings$Weekends + hotel_bookings$Weeknights

# Add HasChildren column
hotel_bookings$HasChildren <- ifelse(hotel_bookings$Children > 0, 1, 0)

# Add HasRequest column
hotel_bookings$HasRequests <- ifelse(hotel_bookings$Requests > 0, 1, 0)

# Add Online column
hotel_bookings$Online <- ifelse(hotel_bookings$Market == "Online", 1, 0)

# Preview the data
# head(hotel_bookings)

```

# 1. Project Description

Gold Mine Resorts is looking to understand the predictors for guests who cancel their reservations. The industry average for cancellation rates is twenty percent; however Gold Mine Resorts experienced a 32.8% cancellation rate for reservations between 2015 and 2018. Cancelled reservations represent a total of $4.3 million dollars in lost revenue for this time frame.

*Description of the dataset*

The dataset includes 36,285 rows of booking data, spanning the course of four years (2015-2018). Data collected includes the group size (adult and children), the stay length (count of weekend and weeknight stays), guest upgrades (parking, meal plans, room types and count of special requests), booking details (price and reservation method), the date of stay, year, and status (whether or not the guest cancelled the reservation).

Our team observed there was only one row of data for year 2015 and 2016. We additionally noticed there only 5 data points for meal plan 3. The variables: GroupSize, StayLength, HasChildren, HasRequests and Online were created from the existing dataset. GroupSize was an aggregation of count of adults and children, StayLength was an aggregation of Weekend and Weeknights. HasChildren, HasRequests and Online created binary, true/false (0 and 1) variables from the count of children, requests and instances where the market was online.

The status column (cancelled versus not cancelled), is the response variable of interest in this analysis.

*Goal of study*

The goal of this analysis is to understand the best predictors for guest cancellations in order to develop company policy in response to predicted cancellations. 

## 1.1 Research Objectives

**Objective 1:**  

The first objective will explore and define the most important numeric variable to predict the percentage that a group will cancel their reservation.

**Objective 2:**

The second objective will explore and define the most important category type variable for predicting the percentage chance a group will cancel their reservation.

**Objective 3:**

The final goal of our statistical analysis will combine our understanding of numeric and category type variables in order to create a statistical model to predict the percent chance that a customer will cancel.


## 1.2 Variables

The response variable of interest is status, whether or not a client cancelled their booking. The possible explanatory variables include both categorical and quantitative options. The number of requests from a client was treated as a categorical variable. Additionaly a new variable called "HasRequests" was created. It is a binary variable with "1" indicating the customer had a special request or "0" otherwise. We made a similar to transformation to the children column, creating a variable "HasChildren" indicating whether or not there were children in the group. We also made the variables "StayLength" which was the length of the stay (Weekends and weeknights), and "GroupSize" which was the size of the group (Adults plus Children).


*Table of variable names and types*

| Variable    | Description of Variable            | Variable Type |
|-------------|-------------------------------------|--------------|
| Status      | Cancellation status of booking      | C            |
| Meal        | Type of meal plan selected          | C            |
| Parking     | Parking option selection            | C            |
| RoomType    | Type of room booked                 | C            |
| Market      | Market segment of booking           | C            |
| Month       | Month of booking date               | C            |
| HasChildren | Indicator for children as guests    | C            |
| HasRequests | Indicator for special requests      | C            |
| Online      | Indicator for an online booking     | C            |
| Requests    | Number of special requests made     | Q            |
| Adults      | Number of adults in the booking     | Q            |
| Children    | Number of children in the booking   | Q            |
| GroupSize   | Number of people in the group       | Q            |
| StayLength  | Total length of stay (nights)       | Q            |
| Weekends    | Number of weekend nights stayed     | Q            |
| Weeknights  | Number of weeknights stayed         | Q            |
| LeadTime    | Num. of days bw booking & arrival   | Q            |
| AvgPrice    | Avg. room price (week of booking)   | Q            |
| Year        | Year of the reservation             | Q            |


\pagebreak

#  2. Detailed Exploratory Data Analysis (EDA)

### Quantitative EDA

For our quantitative exploration we used side by side box plots for every variable to status. Looking at the side by side box plot, the lead time seems to have the largest mean variation when looking at a difference in status. This indicates it might be the best predictor for predicting cancellation rates. Conversely the variables: GroupSize, StayLength, AvgPrice, Adults, and Children do not seem to be strong individual predictors for cancellation rates.

```{r, echo=FALSE}
# quantitative EDA

# Compare means of each quantitative variable between canceled and not canceled groups
group_comparison <- hotel_bookings %>%
  group_by(Status) %>%
  summarize(
    Mean_LeadTime = mean(LeadTime, na.rm = TRUE),
    Mean_AvgPrice = mean(AvgPrice, na.rm = TRUE),
    Mean_GroupSize = mean(GroupSize, na.rm = TRUE),
    Mean_StayLength = mean(StayLength, na.rm = TRUE)
  )

# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
  mutate(across(where(is.numeric), ~round(., 3)))

# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)


hotel_long <- hotel_bookings %>%
  select(Status, LeadTime, AvgPrice, GroupSize, StayLength) %>%
  pivot_longer(cols = c(LeadTime, AvgPrice, GroupSize, StayLength),
               names_to = "Variable",
               values_to = "Value")

# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
  labs(title = "Comparison of quantitative variables by cancellation status") +
  theme_minimal() 

group_comparison <- hotel_bookings %>%
  group_by(Status) %>%
  summarize(
    Mean_LeadTime = mean(Adults, na.rm = TRUE),
    Mean_AvgPrice = mean(Children, na.rm = TRUE),
    Mean_GroupSize = mean(Weekends, na.rm = TRUE),
    Mean_StayLength = mean(Weeknights, na.rm = TRUE)
  )

# Round numeric columns to 3 decimal places
group_comparison_formatted <- group_comparison %>%
  mutate(across(where(is.numeric), ~round(., 3)))

```
\pagebreak

```{r, echo=FALSE}
#second section

# Create pretty kable table
kable(group_comparison_formatted, caption = "Quantitative Explanatory Variables Table 2") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)


hotel_long <- hotel_bookings %>%
  select(Status, Adults, Children, Weekends, Weeknights) %>%
  pivot_longer(cols = c(Adults, Children, Weekends, Weeknights),
               names_to = "Variable",
               values_to = "Value")

# faceted boxplots for quantitative variables
ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
  labs(title = "Comparison of quantitative variables by cancellation status") +
  theme_minimal() 

hotel_long <- hotel_bookings %>%
  select(Status, Requests) %>%
  pivot_longer(cols = c(Requests),
               names_to = "Variable",
               values_to = "Value")

ggplot(hotel_long, aes(x = Status, y = Value, fill = Status)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4")) +
  labs(title = "Comparison of quantitative variables by cancellation status") +
  theme_minimal() 


```

\pagebreak

### Categorical EDA

For our categorical exploration, we investigated: RoomType, Meal, Market, Month, HasRequest, Online (new variable where Market = Online), or if the group had children. Looking at the side by side bar plots we have found the variables: HasRequests, Month, Market, and Online to all be individual indicators of cancellation rates. Looking at the visualizations, the best indicators appear to be: HasRequests, Month, and Market. Other important observations include the very low count for many of the room types, low counts of meal plan three, and low counts for the Aviation market type. These limited data points might be an issue if using these categories to create a model, as they might not be sufficient to cover the conditions.

```{r fig.width=6, fig.height=4, echo=FALSE}
# categorical EDA
# Create a bar chart with white background and title
gf_bar(~RoomType, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancellation by Room Type",
    x = "Room Type",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "bottom"
    )
  )

```

```{r fig.width=7, fig.height=4, echo=FALSE}

gf_bar(~Meal, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancellation by Meal Type",
    x = "Meal Type",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
  )

gf_bar(~Market, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancellation by Market Segment",
    x = "Market Segment",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
  )

```
```{r fig.width=8, fig.height=5.5, echo=FALSE}
# abbreviated month names in chronological order
month_order <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

# Convert Month to factor with levels in chronological order
hotel_bookings$Month <- factor(hotel_bookings$Month, levels = month_order)

# Create the bar chart with chronologically ordered months
gf_bar(~Month, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancellations by Month",
    x = "Month",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
  )

```
```{r fig.width=3, fig.height=4, echo=FALSE}
gf_bar(~HasChildren, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancel by HasChildren",
    x = "Has Children (0 = No, 1 = Yes)",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
  )

gf_bar(~Parking, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancel by Parking",
    x = "Parking",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
  )

gf_bar(~HasRequests, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancel by HasRequest",
    x = "Had a special request",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
)

gf_bar(~Online, fill=~Status, data = hotel_bookings) %>%
  gf_labs(
    title = "Cancel by Online",
    x = "Booking type (1 = Online)",
    y = "Count"
  ) %>%
  gf_refine(
    scale_fill_manual(values = c("Canceled" = "#FF6B6B", "Not_Canceled" = "#4ECDC4"))
  ) %>%
  gf_theme(
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      legend.position = "bottom"
    )
)

```

# 3. Statistical Analysis 

## 3.1 Objective 1

  The metrics used to determine the best quantitative predictor were AIC and residual deviance. All of the individual models created from each variable were statistically significant, with most having a p-value less than $2*10^{-16}$. However, the AIC and residual deviance for the generalized linear model predicting Status with LeadTime was significantly lower than the models for AvgPrice, StayLength, GroupSize, Children, Adults, Weeknights, Weekdays, and Requests, showing that LeadTime is the greatest individual quantitative predictor for Status. Additional the AIC for Groupsize was lower than both individual models for Children and Adults. In the same way, StayLength was a better indicator than Weekends or Weekdays.

  For the conditions of the model using LeadTime, there is slight concern about the equal variance condition. Due to slight flaring of the logit plot, we attempted a variety of transformations (square root, logarithmic, inverse), but this had almost no impact on the conditions and made the model unnecessarily complicated. Additionally there were issues of equal variance for all the quantitative variables. After this analysis, we decided that LeadTime is the best individual quantitative predictor for status.


```{r fig.width=7, fig.height=4.5, echo=FALSE}

# quantitative predictors
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
#summary(price_model)

leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
#summary(leadtime_model)

staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
#summary(staylength_model)

groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
#summary(groupsize_model)

#ASSESS
#converts status to binary where Canceled = 1 and Not_Canceled = 0, checking for linearity
hotel_bookings$Status_binary <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
emplogitplot1(Status_binary ~ LeadTime, data = hotel_bookings, ngroups = "all")
plot(leadtime_model, which = 1)

#USE
# summary(leadtime_model)

```

\pagebreak

# Quantitative Model

  LeadTime has a a p-value of less than $2*10^{-16}$, we have strong evidence that LeadTime is a statistically significant predictor for cancellation rates.

**Logit function for Status using LeadTime:**

$$\widehat{log(\frac{\pi}{1-\pi})} = 1.8046260 - 0.0117484(LeadTime)$$

Using the logit function above, for every 1 day increase in LeadTime, the predicted logit of cancellation rate decreases by 0.011748. 
 
**Odds for Status using LeadTime:**

$$odds(Status) = e^{1.8046260 - 0.0117484(LeadTime)} $$

$$odds \space ratio = e^{\widehat \beta_1} = e^{-0.0117484} = 0.988324$$ 

Therefore, for every 1 day increase in LeadTime, the predicted odds of cancelling the hotel booking decreases by a factor of 0.988. To further Gold Mine Resorts's understanding of these statistics, Visuals of the probabilities and odds of cancellation are included below.

**Probability function for Status using LeadTime:**

$$p(Status) = \widehat \pi = \frac{e^{1.8046260 - 0.0117484(LeadTime)}}{1-e^{1.8046260 - 0.0117484(LeadTime)}}$$


```{r fig.width=8, fig.height=7, echo=FALSE}

# Parameters from your logistic regression model
intercept <- 1.8046260
lead_time_coef <- -0.0117484

# Function to calculate probability of cancellation
cancellation_probability <- function(lead_time) {
  logit <- intercept + (lead_time_coef * lead_time)
  probability <- 1 / (1 + exp(-logit))
  return(probability)
}

# Function to calculate odds of cancellation
cancellation_odds <- function(lead_time) {
  prob <- cancellation_probability(lead_time)
  odds <- prob / (1 - prob)
  return(odds)
}

# Create a sequence of lead times from 0 to 365 days
lead_times <- seq(0, 365, by = 1)

# Calculate probabilities and odds for each lead time
probabilities <- sapply(lead_times, cancellation_probability)
odds <- sapply(lead_times, cancellation_odds)

# Create a data frame for plotting
plot_data <- data.frame(
  LeadTime = lead_times,
  Probability = probabilities,
  Odds = odds
)

# Create visualization
# Set up a 2x1 plotting layout
par(mfrow = c(2, 1), mar = c(4, 4, 2, 2))

# Plot 1: Probability vs Lead Time
plot(plot_data$LeadTime, plot_data$Probability, 
     type = "l", col = "royalblue", lwd = 2,
     xlab = "Lead Time (days)", ylab = "Probability of Cancellation",
     main = "Probability of Cancellation vs Lead Time", 
     ylim = c(0, 1))
grid()

# Add reference points
reference_points <- c(0, 30, 60, 90, 180, 365)
reference_probs <- sapply(reference_points, cancellation_probability)
points(reference_points, reference_probs, pch = 19, col = "#FF6B6B")

# Add labels for probability reference points
text(reference_points, reference_probs, 
     labels = paste0(round(reference_probs*100, 1), "%"), 
     pos = 3, col = "gray11")

# Plot 2: Odds vs Lead Time
plot(plot_data$LeadTime, plot_data$Odds, 
     type = "l", col = "midnightblue", lwd = 2,
     xlab = "Lead Time (days)", ylab = "Odds of Cancellation",
     main = "Odds of Cancellation vs Lead Time",
     ylim = c(0, 6))
grid()

# Add reference points for odds
reference_odds <- sapply(reference_points, cancellation_odds)
points(reference_points, reference_odds, pch = 19, col = "#FF6B6B")

# Add labels for odds reference points
text(reference_points, reference_odds, 
     labels = paste0(round(reference_odds, 2)), 
     pos = 3, col = "gray11")

# Reset plotting parameters
par(mfrow = c(1, 1))

```

\pagebreak

## 3.2 Objective 2

  Looking at the AIC for the categorical models, HasRequests was shown to be the best single categorical explanatory variable for predicting cancellations. This is within the expectations of our exploratory data analysis, as it was also followed by Month and Market.

  For our categorical analysis, we transformed Requests (a quantitative variable) into a categorical variable, HasRequests, that indicates whether or not a given booking made a nonzero number of special requests. As evidenced by the model output for HasRequests, we note that the p-value for the variable's coefficient is less than $2*10^{-16}$, meaning that HasRequests is statistically significant for predicting cancellation rate. Using a confidence interval, we are 95% certain that for bookings with special requests, the logarithmic likelihood of a cancellation will increase by a factor of between 1.05 and 1.14.
  
  The conditions for our model are met because we have many instances for guests making requests and guests not making requests, as indicated by table 9 (Has Requests) in the appendix.

**Logit function for Status using HasRequests:**

$$\widehat{log(\frac{\pi}{1-\pi})} = 0.27328 + 1.09756(HasRequests)$$

**Probability function for Status using HasRequests:**

$$p(Status) = \widehat \pi = \frac{e^{0.27328 + 1.09756(HasRequests)}}{1-e^{0.27328 + 1.09756(HasRequests)}}$$
**odds for Status using HasRequests:**

$$odds(Status) = e^{0.27328 + 1.09756(HasRequests)} $$


$$odds \space ratio = e^{\widehat \beta_1} = e^{1.09756} = 2.996845$$ 

HasRequests is a binary categorical variable. When HasRequests = 1 (at least special request was made), the predicted odds of not cancelling are approximately 3 times higher than when HasRequests = 0 (no special requests were made).

```{r fig.width=6, fig.height=4, echo=FALSE}

modr <- glm(factor(Status) ~ HasRequests, family = binomial(link = "logit"), data = hotel_bookings)
# summary(modr)

plot(modr, which = 1)

#confidence interval for HasRequests
#confint.default(modr)

mod1 <- glm(factor(Status) ~ RoomType, family = binomial(link = "logit"), data = hotel_bookings)
# summary(mod1)

# plot(mod1, which = 1)

mod2 <- glm(factor(Status) ~ Parking, family = binomial(link = "logit"), data = hotel_bookings)
# summary(mod2)

# plot(mod2, which = 1)

mod3 <- glm(factor(Status) ~ Market, family = binomial(link = "logit"), data = hotel_bookings)
# summary(mod3)

# plot(mod3, which = 1)

mod4 <- glm(factor(Status) ~ Meal, family = binomial(link = "logit"), data = hotel_bookings)
# summary(mod4)

# plot(mod4, which = 1)

# mod5 <- glm(factor(Status) ~ Month, family = binomial(link = "logit"), data = hotel_bookings)
# summary(mod5)

#plot(mod5, which = 1)

```

\pagebreak

## 3.3 Objective 3

  When observing the ANOVA table, the HasChildren variable was not statistically significant. We replaced the HasChildren variable with the Children variable and observed a large p value for this created indicator column as well (greater than .2 in both instances). We additionally removed Year from the statistical model, since this historical data point is not useful for future predictions.

  Using forward step analysis, the AIC values recommended using all the remaining variables, including LeadTime, HasRequests, Market, Month, AvgPrice, Parking, RoomType, StayLength, Meal and GroupSize. The AIC of this model was 30,674. 

  We used the output from an ANOVA table to eliminate variables one at a time, starting with GroupSize (the highest p value). The final model we selected used LeadTime, Market, Requests, Month, AvgPrice, and StayLength. While our AIC increased slightly to 31,109, we reduced the variable count from 10 to 6. Simplifying the model to six variables is far easier to utilize for improvements to Gold Mine Resorts marketing procedures, and only changed the AIC value by 1.4%. Additionally, our model had good variance and normality, in addition to fitting closely to the expected results (as indicated by the empirical logit plot).
  
**Cross Validation**

  After running two cross validation tests, we observed the percent difference in AIC to be -.245% and 1.19%. This metric shows our model does not have any indicators for over fitting.


```{r, echo=FALSE}
# included again in the appendix, left here for use in the empirical logit plot
new_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests + factor(Month) + AvgPrice + StayLength, family = binomial(link = "logit"), data=hotel_bookings)


anova_table <- Anova(new_model, test = "LR")

```

```{r fig.width=7, fig.height=4.5, echo=FALSE}
#ASSESS

# Create an empirical logit plot for the entire model
plot_model_fit <- function(model, bins = 10) {
  # Get predicted probabilities from the model
  pred_probs <- predict(model, type = "response")
  
  # Get actual responses (as 0/1)
  actual <- as.numeric(model$model[[1]]) - 1
  
  # Create bins based on predicted probabilities
  breaks <- quantile(pred_probs, probs = seq(0, 1, length.out = bins + 1))
  bin_groups <- cut(pred_probs, breaks = breaks, include.lowest = TRUE)
  
  # Calculate empirical logit for each bin
  bin_data <- data.frame(
    bin = bin_groups,
    pred = pred_probs,
    actual = actual
  )
  
  # Calculate average predicted probability and observed proportion for each bin
  bin_summary <- aggregate(cbind(pred, actual) ~ bin, data = bin_data, 
                         FUN = function(x) c(mean(x)))
  
  # Calculate empirical logit
  bin_summary$logit_pred <- log(bin_summary$pred / (1 - bin_summary$pred))
  bin_summary$logit_actual <- log((bin_summary$actual + 0.5/nrow(bin_summary)) / 
                               (1 - bin_summary$actual + 0.5/nrow(bin_summary)))
  
  # Count observations per bin
  bin_counts <- table(bin_groups)
  bin_summary$count <- as.vector(bin_counts)
  
  # Create plot
  plot(bin_summary$logit_pred, bin_summary$logit_actual,
       xlab = "Predicted logit", ylab = "Observed logit",
       main = "Empirical Logit Plot for Model Fit",
       pch = 19, cex = sqrt(bin_summary$count / max(bin_summary$count)) * 2)
  
  # Add reference line (y = x)
  abline(0, 1, col = "red", lty = 2)
  
  # Add regression line
  abline(lm(logit_actual ~ logit_pred, data = bin_summary, 
          weights = count), col = "blue")
  
  # Add legend
  legend("topleft", legend = c("Perfect fit", "Actual fit"), 
         col = c("red", "blue"), lty = c(2, 1))
  
  return(bin_summary)
}

# Create the empirical logit plot for the model
model_fit <- plot_model_fit(new_model, bins = 10)

# Print the bin summary data
#print(model_fit)

# Other diagnostic plots for the model
plot(new_model, which = c(1, 2))  # Residuals vs Fitted and Normal Q-Q plot

```

\pagebreak

**Key Quantitative Predictors:***

To summarize, the business implication is that longer lead times, higher prices, and longer stays correlate with higher cancellation risk. In addition, LeadTime, AvgPrice, and StayLength have respective p-values of <2e-16, <2e-16, and 7.49e-16, indicating that these variables are useful for predicting cancellation rates.


$$odds \space ratio_{LeadTime} = e^{-0.0161356} = 0.984$$ 

For each additional day in lead time, the predicted odds of not cancelling decrease by a factor of 0.984, holding all other variables constant.

$$odds \space ratio_{AvgPrice} = e^{-0.0145549} = 0.985$$ 

For each \$1 increase in average price, the predicted odds of not cancelling decrease by a factor of 0.985, holding all other variables constant. 

$$odds \space ratio_{StayTime} = e^{-0.0643062} = 0.938$$ 

For each additional night in the hotel, the predicted odds of not cancelling decrease by a factor of 0.938, holding all other variables constant.

**Key Categorical Predictors:**

To summarize, the business implication is that corporate/offline bookings are more reliable than aviation bookings. In addition, the months of February to November have a higher cancellation risk than January. Specifically, the peak cancellation risk occurs in the month of February where the predicted odds of not cancelling decrease by a factor of 0.059 compared to January (holding all other variables constant).

$$odds \space ratio_{HasRequests} = e^{2.0247462} = 7.57$$ 

Holding all other variables constant, when a guest makes at least one special request the predicted odds of not cancelling are approximately 8 times higher than those without special requests. With a p-value <2e-16, this variable is useful to predict Status.

$$odds \space ratio_{Market(Corporate)} = e^{1.0866028} = 2.96$$ 

Holding all other variables constant, when Gold Mine Resorts has a corporate booking the predicted odds of not cancelling are approximately 3 times higher than an aviation booking (baseline). With a p-value of 3.95e-07, this segment is useful in predicting Status.

$$odds \space ratio_{Market(Offline)} = e^{1.6324226} = 5.12$$ 

Holding all other variables constant, when Gold Mine Resorts has an offline booking the predicted odds of not cancelling are approximately 5 times higher than an aviation booking (baseline). With a p-value of 8.80e-16, this segment is useful in predicting Status.

$$odds \space ratio_{Market(Online)} = e^{-0.2199951} = 0.8$$ 

Holding all other variables constant, when Gold Mine Resorts has an online booking the predicted odds of not cancelling decrease by a factor of 0.8 compared to an aviation booking (baseline). However, with a p-value of 0.27308, this segment is not statistically significant in predicting Status.

$$odds \space ratio_{Month(Feb-Nov)} \approx e^{-2.28} = 0.102$$


Holding all other variables constant, when there is a booking made between February to November (all $\beta$'s are relatively similar in range) the predicted odds of not cancelling decrease by a factor of 0.102 when compared to bookings made in January (baseline). Each individual month is statistically significant in predicting Status with p-values <2e-16.

$$odds \space ratio_{Month(Dec)} \approx e^{-0.0643} = 0.55$$ 

Holding all other variables constant, when there is a booking made in December the predicted odds of not cancelling decrease by a factor of 0.55 when compared to bookings made in January (baseline). December is a statistically significant segment of Month in predicting Status with a p-value of 0.00674.


\pagebreak

# 4. Conclusions 

**Objective 1:**  

  Our final conclusion is that LeadTime is the best single numeric predictor for cancellation rates, even when considering new variables synthesized from the dataset. For every one day increase in lead time, the predicted odds of cancelling the hotel booking decreases slightly. Guests with very large lead times are the most likely to keep their reservation. 

**Objective 2:** 

  When considering only the categories of factors available from the dataset or synthesized, we found that HasRequests is the most useful variable for predicting cancellation rates. If a guest has a reservation request, the predicted of odds of a cancellation decreases by a factor of three.  

**Objective 3:**

  With all of the original and synthesized variables available for our final model, we determined the most useful model for predicting cancellation rates included the predictors of LeadTime, Market, Month, AvgPrice, and StayLength. Gold Mine Resorts should focus on these factors to minimize cancellations in the future.  

  While this model is a good starting point for predicting hotel cancellations, we noticed that there was a significant increase in total reservations between 2017 and 2018. Further, 2018 had a significant spike in online reservations that led to cancellations. If Gold Mine Resorts has access to further details about the sources for online bookings, this may prove to be a beneficial research study in the future. Other factors impacting the economy between 2017 and 2018 may also be useful for predicting cancellations.


```{r  fig.width=6, fig.height=4.5, echo=FALSE}

# side-by-side bar chart of canceled bookings by market type for 2017-2018
# Filter for canceled bookings in 2017 and 2018 only
canceled_bookings <- hotel_bookings[hotel_bookings$Status == "Canceled" & 
                                    (hotel_bookings$Year == 2017 | 
                                     hotel_bookings$Year == 2018), ]

# Create a binary market type variable (Online vs Non-Online)
canceled_bookings$MarketType <- ifelse(canceled_bookings$Market == "Online", 
                                      "Online", "Non-Online")

# Create a contingency table of counts
cancellation_counts <- table(canceled_bookings$Year, canceled_bookings$MarketType)

# Convert to data frame for ggplot
cancellation_df <- as.data.frame(cancellation_counts)
colnames(cancellation_df) <- c("Year", "MarketType", "Count")

# Convert Year to factor for proper ordering
cancellation_df$Year <- as.factor(cancellation_df$Year)

# Create the side-by-side (unstacked) bar chart
ggplot(cancellation_df, aes(x = Year, y = Count, fill = MarketType)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  scale_fill_manual(values = c("Online" = "darkblue", "Non-Online" = "azure4")) +
  labs(title = "Canceled Bookings by Market Type (2017-2018)",
       subtitle = "Side-by-side comparison of Online vs Non-Online Markets",
       x = "Year",
       y = "Number of Cancellations",
       fill = "Market Type") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "bottom",
    legend.title = element_text(size = 11),
    legend.text = element_text(size = 10),
    panel.grid = element_blank()  # Keep the gridlines removed
  ) +
  # Add data labels on top of each bar
  geom_text(aes(label = Count), position = position_dodge(width = 0.7), 
            vjust = -0.5, size = 3.5) +
  # Set y-axis to start at 0
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))

```

\pagebreak

# 5. Appendix 

Below are tables used in our exploratory data analysis, followed by the statistical output of our models and cross validation.

**Data Tables**

```{r, echo=FALSE}
# function to generate proportion tables
create_prop_table <- function(data, group_var) {
  group_var <- enquo(group_var)
  
  data %>%
    group_by(!!group_var, Status) %>%
    summarise(count = n(), .groups = "drop") %>%
    group_by(!!group_var) %>%
    mutate(proportion = count / sum(count))
}

# using the function with each variable
room_type_table <- create_prop_table(hotel_bookings, RoomType)
meal_table <- create_prop_table(hotel_bookings, Meal)
market_table <- create_prop_table(hotel_bookings, Market)
parking_table <- create_prop_table(hotel_bookings, Parking)
month_table <- create_prop_table(hotel_bookings, Month)
requests_table <- create_prop_table(hotel_bookings, HasRequests)
children_table <- create_prop_table(hotel_bookings, HasChildren)
online_table <- create_prop_table(hotel_bookings, Online)
requests_table2 <- create_prop_table(hotel_bookings, Requests)

# using the function to create a nicely formatted kable table with rounded proportions
print_pretty_kable <- function(table_data, title) {
  table_data <- table_data %>%
    mutate(proportion = round(proportion, 3))
  
  kable(table_data, caption = title) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                  full_width = FALSE) %>%
    column_spec(1, bold = TRUE) %>%
    row_spec(0, bold = TRUE)
}

#printed tables are separated with lines of code to prevent awkward cut offs

# Print each table with nice formatting
print_pretty_kable(room_type_table, "Room Type")
print_pretty_kable(meal_table, "Meal Option")

```
\pagebreak

```{r, echo=FALSE}
# Print each table with nice formatting
print_pretty_kable(market_table, "Market")
print_pretty_kable(parking_table, "Parking")

```
\pagebreak

```{r, echo=FALSE}
# Print each table with nice formatting
print_pretty_kable(month_table, "Month")
print_pretty_kable(requests_table, "Has Requests")

```

\pagebreak

```{r, echo=FALSE}
# Print each table with nice formatting
print_pretty_kable(children_table, "Has Children")
print_pretty_kable(online_table, "Online Booking")
print_pretty_kable(requests_table2, "Requests")

```
**Quantitative Variable Models**

```{r fig.width=7, fig.height=4.5, include=TRUE}
# quantitative code
hotel_bookings$Status_binary <- ifelse(hotel_bookings$Status == "Canceled", 1, 0)
price_model <- glm(factor(Status) ~ AvgPrice, family = binomial(link = "logit"), data = hotel_bookings)
summary(price_model)
emplogitplot1(Status_binary ~ AvgPrice, data = hotel_bookings, ngroups = "all")

leadtime_model <- glm(factor(Status) ~ LeadTime, family = binomial(link = "logit"), data = hotel_bookings)
summary(leadtime_model)
emplogitplot1(Status_binary ~ LeadTime, data = hotel_bookings, ngroups = "all")

staylength_model <- glm(factor(Status) ~ StayLength, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
emplogitplot1(Status_binary ~ StayLength, data = hotel_bookings, ngroups = "all")

groupsize_model <- glm(factor(Status) ~ GroupSize, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ GroupSize, data = hotel_bookings, ngroups = "all")

groupsize_model <- glm(factor(Status) ~ Adults, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Adults, data = hotel_bookings, ngroups = "all")

groupsize_model <- glm(factor(Status) ~ Children, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Children, data = hotel_bookings, ngroups = "all")

groupsize_model <- glm(factor(Status) ~ Weekends, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Weekends, data = hotel_bookings, ngroups = "all")

groupsize_model <- glm(factor(Status) ~ Weeknights, family = binomial(link = "logit"), data = hotel_bookings)
summary(groupsize_model)
emplogitplot1(Status_binary ~ Weeknights, data = hotel_bookings, ngroups = "all")

staylength_model <- glm(factor(Status) ~ Requests, family = binomial(link = "logit"), data = hotel_bookings)
summary(staylength_model)
emplogitplot1(Status_binary ~ Requests, data = hotel_bookings, ngroups = "all")

```
\pagebreak

**Categorical Variable Models**

```{r, include=TRUE}
# categorical code


mod1 <- glm(factor(Status) ~ RoomType, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod1)


mod2 <- glm(factor(Status) ~ Parking, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod2)


mod3 <- glm(factor(Status) ~ Market, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod3)

mod4 <- glm(factor(Status) ~ Meal, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod4)


mod5 <- glm(factor(Status) ~ Month, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)

mod5 <- glm(factor(Status) ~ HasRequests, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)

mod5 <- glm(factor(Status) ~ HasChildren, family = binomial(link = "logit"), data = hotel_bookings)
summary(mod5)

```

**Combined Variable and Final Models**

```{r, include=TRUE}

#full model code
full_model <- glm(factor(Status) ~ factor(Meal) + factor(Parking) + factor(RoomType) + LeadTime + factor(Market) + AvgPrice + HasRequests + factor(Month) + StayLength + GroupSize, family = binomial(link = "logit"), data=hotel_bookings)


none <- glm(factor(Status) ~ 1 , family = binomial(link = "logit"), data=hotel_bookings)
step(none,scope=list(upper= full_model), direction = "forward")

anova_table <- Anova(full_model, test = "LR")
print(anova_table)

#final model code
new_model <- glm(factor(Status) ~ LeadTime + factor(Market) + HasRequests + factor(Month) + AvgPrice + StayLength, family = binomial(link = "logit"), data=hotel_bookings)


anova_table <- Anova(new_model, test = "LR")
print(anova_table)

# Get the AIC
AIC(new_model)

```

**Cross Validation**

```{r, echo=FALSE}
#cross validation
set.seed(123)

train_indices <- sample(1:nrow(hotel_bookings), size = 0.5 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]

train_model <- glm(factor(Status) ~ LeadTime + HasRequests + factor(Market) + factor(Month) + 
    AvgPrice + factor(Parking) + factor(RoomType) + StayLength + factor(Meal) + StayLength, 
                  family = binomial(link = "logit"), 
                  data = train_data)
summary(train_model)
anova(train_model)

train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")

train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1

logL <- sum(test_actual * log(test_predictions) + (1 - test_actual) * log(1 - test_predictions))

k <- length(coef(train_model))

aic_test <- 2 * k - 2 * logL

(aic_test - AIC(train_model))/AIC(train_model)

```

```{r, echo=FALSE}
#cross validation
set.seed(456)

train_indices <- sample(1:nrow(hotel_bookings), size = 0.5 * nrow(hotel_bookings))
train_data <- hotel_bookings[train_indices, ]
test_data <- hotel_bookings[-train_indices, ]

train_model <- glm(factor(Status) ~ LeadTime + HasRequests + factor(Market) + factor(Month) + 
    AvgPrice + factor(Parking) + factor(RoomType) + StayLength + factor(Meal) + StayLength, 
                  family = binomial(link = "logit"), 
                  data = train_data)
summary(train_model)
anova(train_model)

train_predictions <- predict(train_model, newdata = train_data, type = "response")
test_predictions <- predict(train_model, newdata = test_data, type = "response")

train_actual <- as.numeric(factor(train_data$Status)) - 1
test_actual <- as.numeric(factor(test_data$Status)) - 1

logL <- sum(test_actual * log(test_predictions) + (1 - test_actual) * log(1 - test_predictions))

k <- length(coef(train_model))

aic_test <- 2 * k - 2 * logL

(aic_test - AIC(train_model))/AIC(train_model)

```
